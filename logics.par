// Grammar for ViUR logics
// Compile with UniCC (https://github.com/phorward/unicc) using `unicc -swo parser -l python logics.par`

#!mode          scanner;
#whitespaces    @whitespace ;

@whitespace     ' \r\n\t'+
                | "#" !'\n'* '\n'
                ;

@IDENT          'A-Za-z_' 'A-Za-z0-9_'*                             = IDENT;
@STRING         '"' ( '\\' . | !'"' )* '"'
                | '\'' ( '\\' . | !'\'' )* '\''                     = STRING;
@NUMBER         '0-9'+ '.' '0-9'* | '0-9'* '.' '0-9'+ | '0-9'+      = NUMBER;

logic$          : expression ;

expression      : test ;

test            : if_else
                | or_test
                ;

if_else         := or_test "if" or_test "else" test
                ;

or_test         : and_test ( "or" and_test )+                     = or_test
                | and_test
                ;

and_test        : not_test ( "and" not_test )+                    = and_test
                | not_test
                ;

not_test        : "not" not_test                                  = not_test
                | comparison
                ;

in              := "in" ;
not_in          := "not" "in" ;

comparison_op   : ""==""
                | "">=""
                | ""<=""
                | ""<""
                | "">""
                | ""<>""
                | ""!=""
                | in
                | not_in
                ;

comparison      : expr (comparison_op expr )+                       = comparison
                | expr
                ;

expr            : expr '+' term                                     = add
                | expr '-' term                                     = sub
                | term
                ;

term            : term '*' factor                                   = mul
                | term '/' factor                                   = div
                | term '%' factor                                   = mod
                | factor;

factor          : '+' factor                                        = plus
                | '-' factor                                        = minus
                | '~' factor                                        = complement
                | power
                ;

power           : entity "**" factor                                = power
                | entity
                ;

entity          : atom trailer+                                     = entity
                | atom
                ;

opt_expression  : expression
                |                                                   = null
                ;

trailer         : '(' list ')'
                | '[' expression ']'
                | '[' opt_expression ':' opt_expression ']'         = slice
                | '.' @IDENT
                ;

atom            : ( ""True"" | ""False"" )
                | @NUMBER
                | @IDENT
                | @STRING
                | @STRING+                                          = concat
                | comprehension
                | '[' list ']'
                | '(' expression ')'                                = atom
                ;

comprehension   := '[' expression "for" @IDENT "in" or_test ( "if" expression )? ']'
                ;

list            := expression (',' expression )*
                |
                ;
